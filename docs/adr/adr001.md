# ADR 001 – Adoption d'une Saga Chorégraphiée pour la Coordination Distribuée

## Statut
Acceptée

## Contexte
Lors de la transition vers une architecture microservices (Labo 05), nous avions initié le traitement des commandes avec une saga orchestrée. Cependant, au fur et à mesure que l'architecture évoluait vers une communication asynchrone basée sur Kafka (Labo 07-08), nous nous sommes confrontés à plusieurs défis :

1. **Orchestrateur comme point de défaillance unique** : Un orchestrateur centralisé crée une dépendance critique qui peut devenir un goulot d'étranglement ou un point de défaillance unique
2. **Couplage serré entre services** : L'orchestrateur doit connaître l'adresse de chaque service et gérer tous les appels HTTP synchrones
3. **Scalabilité limitée** : Les appels HTTP synchrones bloquent l'orchestrateur pendant l'attente des réponses
4. **Difficulté à gérer les services hors ligne** : Si un service est indisponible, l'orchestrateur doit attendre ou gérer des timeouts
5. **Complexité du code d'orchestration** : La logique de coordination devient concentrée dans une seule classe, rendant le code difficile à maintenir et à tester

En parallèle, nous avons adopté Kafka comme event broker pour permettre une communication asynchrone entre microservices, ce qui a naturellement conduit à explorer une approche alternative de coordination.

## Décision
Nous avons décidé d'adopter une **Saga Chorégraphiée** basée sur Kafka en tant qu'event broker pour coordonner les transactions distribuées dans notre architecture microservices. Cette décision s'aligne avec notre évolution vers une architecture event-driven et cloud-native. Cette décision s'aligne avec les tendances modernes de l'architecture logicielle et les meilleures pratiques cloud-native :

1. **Microservices et Event-Driven** : L'architecture event-driven est appropriée pour les systèmes distribués modernes
2. **Scalabilité Horizontale** : Les architectures basées sur des événements asynchrones permettent une meilleure scalabilité
3. **Résilience** : les patrons event-driven et Outbox offrent une meilleure tolérance aux pannes et la possibilité de réessayer les opérations échoués